#include <stdio.h>
#include <stdlib.h>

#include <cuda.h>
#include <curand_kernel.h>
#include <math_constants.h>

extern "C"
{

__global__ void set_seed ( curandState * state, unsigned long seed, int idx)
{
    curand_init ( seed, id, 0, &state[idx] );
}

__device__ float rnorm( curandState* globalState, int idx, float* mu, float* sigma )
{
    curandState localState = globalState[idx];
    float rv = sigma[idx] * curand_normal( &localState ) + mu[idx];
    globalState[idx] = localState;
    return rv;
}

__global__ void
rtruncnorm_kernel(float *vals, int n,
                  float *mu, float *sigma,
                  float *lo, float *hi,
                  int mu_len, int sigma_len,
                  int lo_len, int hi_len,
                  int maxtries)
{
    // Usual block/thread indexing...
    int myblock = blockIdx.x + blockIdx.y * gridDim.x;
    int blocksize = blockDim.x * blockDim.y * blockDim.z;
    int subthread = threadIdx.z*(blockDim.x * blockDim.y) + threadIdx.y*blockDim.x + threadIdx.x;
    int idx = myblock * blocksize + subthread;

    // Setup the RNG:
    curand_init ( time(NULL), seed, idx, 0, &devStates[idx] );

    // Sample:
    int i = 0;
    for( i = 0; i < maxtries; ++i){
    	float rNormSample = rnorm(globalState, idx, mu, sigma);
    	if (rNormSample > lo[idx] && rNormSample < hi[idx]){
    	    		vals[idx] = rNormSample;
    	    		break;
    	    	}
    }
    if (i == maxtries) { sprintf("Hit maximum number of tries. Do alternative code"); }

    return;
}

} // END extern "C"

int main()
{
    int N=10000;

    curandState* devStates;
    cudaMalloc ( &devStates, N*sizeof( curandState ) );

    // setup seeds
    setup_kernel <<< 1, N >>> ( devStates,unsigned(time(NULL)) );

    float N2[40000];
    float* N3;
    cudaMalloc((void**) &N3, sizeof(float)*N);

    kernel<<<1,1>>> (N3, devStates, n);

    cudaMemcpy(N2, N3, sizeof(float)*N, cudaMemcpyDeviceToHost);

    for(int i=0;i<N;i++)
    {
        cout<<N2[i]<<endl;
    }

    return 0;
}

